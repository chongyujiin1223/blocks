<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D ç§¯æœ¨æ‹¼å›¾ - 30å…³æŒ‘æˆ˜ç‰ˆ</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; user-select: none; -webkit-touch-callout: none; background: #f0f0f0; }
        #canvas-container { width: 100vw; height: 100vh; display: block; touch-action: none; }
        
        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            box-sizing: border-box;
            z-index: 10;
        }

        #header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 15px;
            background: linear-gradient(to bottom, rgba(255,255,255,0.8), rgba(255,255,255,0));
            pointer-events: none; 
        }

        .panel {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(8px);
            padding: 10px 15px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            pointer-events: auto;
            border: 1px solid #ddd;
            max-width: 60%;
            transition: max-height 0.3s ease;
            overflow: hidden;
        }

        .panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }

        h1 { margin: 0; font-size: 18px; color: #333; font-weight: 700; white-space: nowrap; }
        
        /* å¸®åŠ©æŒ‰é’® */
        .icon-btn {
            background: #eee;
            border: none;
            width: 24px;
            height: 24px;
            border-radius: 12px;
            font-size: 14px;
            color: #555;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* æŠ˜å å†…å®¹æ ·å¼ */
        #help-content {
            max-height: 0;
            opacity: 0;
            transition: max-height 0.3s ease, opacity 0.3s ease, margin-top 0.3s ease;
        }
        
        #help-content.expanded {
            max-height: 200px;
            opacity: 1;
            margin-top: 10px;
        }

        .help-list {
            list-style: none;
            padding: 0;
            margin: 0;
            font-size: 12px;
            color: #555;
            line-height: 1.6;
        }
        
        .help-list li {
            margin-bottom: 4px;
            display: flex;
            align-items: flex-start;
        }
        .help-icon {
            margin-right: 6px;
            min-width: 16px;
        }
        
        /* é¡¶éƒ¨æ§åˆ¶åŒº */
        #level-controls {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 8px;
            pointer-events: auto;
        }

        select#level-select {
            padding: 8px;
            font-size: 14px;
            border-radius: 8px;
            border: 1px solid #ccc;
            background: #fff;
            font-weight: bold;
            color: #333;
            max-width: 120px;
        }

        button.text-btn {
            background: #333;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
        }

        #progress-bar {
            width: 100px;
            height: 6px;
            background: #eee;
            border-radius: 3px;
            overflow: hidden;
            border: 1px solid #ddd;
        }
        #progress-fill {
            height: 100%;
            width: 0%;
            background: #4CAF50;
            transition: width 0.3s;
        }

        /* ç§»åŠ¨ç«¯åº•éƒ¨æ§åˆ¶æ  */
        #mobile-controls {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            pointer-events: none; 
        }

        .control-group {
            pointer-events: auto; 
            display: flex;
            gap: 10px;
            position: relative;
        }

        .control-group.vertical {
            flex-direction: column;
        }

        .control-btn {
            width: 50px;
            height: 50px;
            border-radius: 25px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #ccc;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            font-size: 14px;
            font-weight: bold;
            color: #333;
            display: flex;
            justify-content: center;
            align-items: center;
            active: scale(0.95);
            transition: all 0.1s;
            backdrop-filter: blur(4px);
        }

        .control-btn:active {
            background: #eee;
            transform: scale(0.95);
        }

        .control-btn.active-mode {
            background: #4CAF50;
            color: white;
            border-color: #388E3C;
        }

        .big-btn {
            width: 60px;
            height: 60px;
            border-radius: 30px;
            font-size: 24px;
        }

        /* æ¨¡å¼åˆ‡æ¢æç¤º */
        #mode-hint {
            position: absolute;
            bottom: 75px;
            left: 0;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            white-space: nowrap;
        }

        #win-modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            text-align: center;
            display: none;
            pointer-events: auto;
            z-index: 100;
            width: 80%;
            max-width: 300px;
        }
        #win-modal h2 { margin-top: 0; color: #4CAF50; font-size: 24px; }
        
        .modal-btn {
            background: #222;
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            font-size: 16px;
            margin-top: 15px;
        }

    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div id="header">
            <div class="panel">
                <div class="panel-header" onclick="toggleHelp()">
                    <h1>3D ç§¯æœ¨æ‹¼å›¾</h1>
                    <button class="icon-btn">â”</button>
                </div>
                <!-- å¯æŠ˜å çš„å¸®åŠ©å†…å®¹ -->
                <div id="help-content">
                    <ul class="help-list">
                        <li><span class="help-icon">ğŸ‘†</span> <strong>å•æŒ‡æ‹–æ‹½</strong>ï¼šç§»åŠ¨ç§¯æœ¨ / æ—‹è½¬è§†è§’(ç©ºç™½å¤„)</li>
                        <li><span class="help-icon">âœŒï¸</span> <strong>åŒæŒ‡æåˆ</strong>ï¼šç¼©æ”¾è§†è§’å¤§å°</li>
                        <li><span class="help-icon">â†™ï¸</span> <strong>å·¦ä¸‹æŒ‰é’®</strong>ï¼šåˆ‡æ¢ æ°´å¹³/å‚ç›´ ç§»åŠ¨æ–¹å‘</li>
                        <li><span class="help-icon">â†˜ï¸</span> <strong>å³ä¸‹æŒ‰é’®</strong>ï¼šé€‰ä¸­ç§¯æœ¨åï¼Œç‚¹å‡»X/Y/Zæ—‹è½¬</li>
                    </ul>
                </div>
            </div>
            
            <div id="level-controls">
                <select id="level-select"></select>
                <div id="progress-bar"><div id="progress-fill"></div></div>
                <button id="reset-btn" class="text-btn">é‡ç½®</button>
            </div>
        </div>

        <div id="mobile-controls">
            <div class="control-group">
                <div id="mode-hint">å½“å‰æ¨¡å¼: å‚ç›´å‡é™</div>
                <!-- å‚ç›´/æ°´å¹³åˆ‡æ¢ -->
                <button id="toggle-mode-btn" class="control-btn big-btn" onclick="toggleMoveMode()">
                    â†”
                </button>
            </div>
            
            <div class="control-group vertical">
                <!-- æ—‹è½¬æŒ‰é’® -->
                <button class="control-btn" onclick="rotateSelected('x')">XÂ°</button>
                <button class="control-btn" onclick="rotateSelected('y')">YÂ°</button>
                <button class="control-btn" onclick="rotateSelected('z')">ZÂ°</button>
            </div>
        </div>
    </div>

    <div id="win-modal">
        <h2>ğŸ‰ æŒ‘æˆ˜æˆåŠŸ!</h2>
        <p>ç»“æ„å®Œç¾å¥‘åˆã€‚</p>
        <button id="next-level-btn" class="modal-btn">ä¸‹ä¸€å…³</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // --- æ¸¸æˆé…ç½® ---
        const CONFIG = {
            gridSize: 1.0, 
            bounds: { xMin: -15, xMax: 15, yMin: 0, yMax: 20, zMin: -15, zMax: 15 },
            colors: [
                0xE57373, 0x64B5F6, 0x81C784, 0xFFD54F, 0xBA68C8, 0xFF8A65, 
                0x4DD0E1, 0xAED581, 0xFFB74D, 0x9575CD, 0x7986CB, 0x4DB6AC,
                0x546E7A, 0x8D6E63, 0xD4E157, 0xFF7043
            ]
        };

        let scene, camera, renderer;
        let pieces = []; 
        let targetArea = null; 
        let targetVoxels = new Set(); 
        
        // äº¤äº’çŠ¶æ€
        let draggedObject = null;
        let selectedObject = null; 
        let isVerticalMode = false; 
        
        // è§¦æ§ç›¸å…³å˜é‡
        let lastTouchX = 0, lastTouchY = 0;
        let lastPinchDist = 0;
        let isOrbiting = false;
        let isDraggingPiece = false;
        
        const raycaster = new THREE.Raycaster();
        const touchPos = new THREE.Vector2();
        const dragPlane = new THREE.Plane();
        const intersection = new THREE.Vector3();
        const offset = new THREE.Vector3();

        let currentLevelIndex = 0;
        
        // ç›¸æœºå‚æ•°
        let theta = Math.PI / 4, phi = Math.PI / 3, radius = 35;

        // --- å…³å¡å®šä¹‰å·¥å…· ---
        function defineLevel(name, solutionPieces) {
            const target = [];
            const pieces = [];
            solutionPieces.forEach((voxels, index) => {
                target.push(...voxels);
                let minX = Infinity, minY = Infinity, minZ = Infinity;
                voxels.forEach(v => {
                    if(v[0] < minX) minX = v[0];
                    if(v[1] < minY) minY = v[1];
                    if(v[2] < minZ) minZ = v[2];
                });
                const shape = voxels.map(v => [v[0]-minX, v[1]-minY, v[2]-minZ]);
                pieces.push({ shape: shape, color: index });
            });
            return { name, target, pieces };
        }

        // --- 30ä¸ªå…³å¡æ•°æ® ---
        const LEVELS = [
            // 1-5 åŸºç¡€å…¥é—¨
            defineLevel("1. ç«‹ä½“è§’æŸ±", [[[0,0,0], [1,0,0], [0,1,0], [0,0,1]], [[1,1,1], [0,1,1], [1,0,1], [1,1,0]]]),
            defineLevel("2. é²ç­é”åŸºç¡€", [[[1,0,0], [1,1,0], [1,2,0], [0,1,0], [2,1,0]], [[1,1,1], [1,1,2], [0,1,1], [2,1,1], [1,0,1]], [[0,0,0], [0,0,1], [2,0,0], [2,0,1], [1,0,1]]]),
            defineLevel("3. Lå‹å¯¹æ‹¼", [[[0,0,0], [1,0,0], [0,1,0], [0,0,1], [1,0,1]], [[1,1,1], [0,1,1], [1,0,1], [1,1,0], [0,1,0]]]),
            defineLevel("4. äº•å­—å¡”", [[[0,0,0], [2,0,0], [0,2,0], [2,2,0], [1,1,0]], [[0,0,1], [2,0,1], [0,2,1], [2,2,1], [1,1,1]], [[0,0,2], [2,0,2], [0,2,2], [2,2,2], [1,1,2]], [[1,0,0], [0,1,0], [2,1,0], [1,2,0], [1,0,1], [0,1,1]]]),
            defineLevel("5. è›‡å½¢ç¼ ç»•", [[[0,0,0], [1,0,0], [1,1,0], [1,1,1], [2,1,1]], [[0,0,1], [0,1,1], [0,1,0], [0,2,0], [1,2,0]], [[2,0,0], [2,0,1], [2,1,0], [2,2,1], [1,2,1]]]),
            
            // 6-12 è¿›é˜¶æŒ‘æˆ˜
            defineLevel("6. å‡¹å‡¸é­”æ–¹", [[[0,0,0], [1,0,0], [0,1,0], [0,0,1], [1,1,0]], [[2,2,2], [1,2,2], [2,1,2], [2,2,1], [1,1,2]], [[0,2,0], [1,2,0], [0,2,1], [0,1,1], [1,1,1]], [[2,0,2], [1,0,2], [2,0,1], [2,1,1], [1,0,1]], [[2,0,0], [2,1,0], [2,2,0], [1,2,1], [1,0,0], [0,1,2], [0,2,2]]]),
            defineLevel("7. å·¥ä¸šæ”¯æ¶", [[[0,0,0], [0,1,0], [0,2,0], [1,0,0], [2,0,0]], [[2,2,0], [2,1,0], [1,2,0], [0,2,1], [0,2,2]], [[2,0,2], [2,0,1], [2,1,2], [1,0,2], [0,0,2]], [[1,1,1], [1,1,0], [1,1,2], [0,1,1], [2,1,1]]]),
            defineLevel("8. ä¿„ç½—æ–¯æ–¹å—å¢™", [[[0,0,0], [1,0,0], [1,1,0], [2,1,0], [1,1,1]], [[0,1,0], [0,2,0], [1,2,0], [0,1,1], [0,2,1]], [[2,0,0], [2,0,1], [1,0,1], [1,0,2], [2,0,2]], [[2,2,0], [2,2,1], [1,2,1], [2,1,1], [2,1,2]]]),
            defineLevel("9. ç©ºå¿ƒç«‹æ–¹ä½“", [[[0,0,0], [1,0,0], [2,0,0], [0,1,0], [0,2,0]], [[0,0,1], [0,0,2], [1,0,2], [2,0,2], [2,0,1]], [[2,1,2], [2,2,2], [1,2,2], [0,2,2], [0,2,1]], [[2,2,1], [2,2,0], [1,2,0], [2,1,0], [2,1,1]]]),
            defineLevel("10. èºæ—‹é˜¶æ¢¯", [[[0,0,0], [1,0,0], [1,0,1], [0,0,1], [0,1,1]], [[0,2,2], [1,2,2], [1,2,1], [0,2,1], [1,1,1]], [[2,0,0], [2,1,0], [2,2,0], [2,2,1], [2,1,1]], [[0,1,0], [1,1,0], [2,1,0], [2,0,1], [2,0,2]]]),
            defineLevel("11. å·¨çŸ³é˜µ", [[[0,0,0], [1,0,0], [2,0,0], [3,0,0], [0,1,0], [3,1,0], [0,0,1], [3,0,1]], [[0,0,2], [1,0,2], [2,0,2], [3,0,2], [0,1,2], [3,1,2], [0,0,3], [3,0,3]], [[1,1,0], [2,1,0], [1,1,2], [2,1,2]], [[1,2,1], [2,2,1], [1,2,0], [2,2,0], [1,2,2], [2,2,2]]]),
            defineLevel("12. æ‘©å¤©æ¥¼", [[[0,0,0], [1,0,0], [0,1,0], [1,1,0], [0,2,0], [1,2,0], [0,3,0], [1,3,0]], [[2,0,0], [2,1,0], [2,2,0], [2,0,1], [2,1,1], [2,2,1], [2,0,2], [2,1,2]], [[0,0,1], [1,0,1], [0,1,1], [1,1,1], [0,0,2], [1,0,2]], [[0,2,1], [1,2,1], [0,3,1], [1,3,1], [0,2,2], [1,2,2]]]),
            
            // 13-20 å»ºç­‘ä¸äº’é”
            defineLevel("13. åŒå­å¡”", [[[0,0,0],[1,0,0],[0,1,0],[1,1,0],[0,0,1],[1,0,1],[0,1,1],[1,1,1]], [[3,0,0],[4,0,0],[3,1,0],[4,1,0],[3,0,1],[4,0,1],[3,1,1],[4,1,1]], [[0,2,0],[1,2,0],[2,2,0],[3,2,0],[4,2,0],[2,3,0]], [[0,2,1],[1,2,1],[2,2,1],[3,2,1],[4,2,1],[2,3,1]]]),
            defineLevel("14. å‡¯æ—‹é—¨", [[[0,0,0],[0,1,0],[0,2,0],[0,3,0],[1,0,0],[1,1,0]], [[3,0,0],[3,1,0],[3,2,0],[3,3,0],[2,0,0],[2,1,0]], [[0,4,0],[1,4,0],[2,4,0],[3,4,0],[1,3,0],[2,3,0]], [[0,0,1],[0,1,1],[0,2,1],[0,3,1],[1,0,1],[1,1,1]], [[3,0,1],[3,1,1],[3,2,1],[3,3,1],[2,0,1],[2,1,1]], [[0,4,1],[1,4,1],[2,4,1],[3,4,1],[1,3,1],[2,3,1]]]),
            defineLevel("15. å›å½¢èµ°å»Š", [[[0,0,0],[1,0,0],[2,0,0],[3,0,0],[0,1,0],[3,1,0]], [[3,0,1],[3,0,2],[3,0,3],[3,1,3],[3,1,2],[3,1,1]], [[3,0,3],[2,0,3],[1,0,3],[0,0,3],[0,1,3],[1,1,3],[2,1,3]], [[0,0,3],[0,0,2],[0,0,1],[0,1,1],[0,1,2]]]),
            defineLevel("16. åå­—è¦å¡", [[[2,0,2],[2,1,2],[2,2,2],[2,3,2],[2,4,2],[1,2,2],[3,2,2],[2,2,1],[2,2,3]], [[1,0,1],[1,0,2],[1,0,3],[0,0,2],[2,0,1],[2,0,3],[3,0,2],[4,0,2]], [[0,4,2],[1,4,2],[2,4,1],[2,4,3],[3,4,2],[4,4,2]], [[1,1,1],[3,1,3],[1,3,3],[3,3,1]]]),
            defineLevel("17. DNAèºæ—‹", [[[0,0,0],[1,0,0],[0,0,1]], [[1,1,0],[2,1,0],[2,1,1]], [[2,2,1],[3,2,1],[3,2,2]], [[3,3,2],[2,3,2],[2,3,3]], [[1,4,3],[2,4,3],[1,4,2]], [[0,5,2],[1,5,2],[0,5,3]]]),
            defineLevel("18. Uå‹æ½œè‰‡", [[[0,0,0],[1,0,0],[2,0,0],[3,0,0],[4,0,0],[0,1,0],[4,1,0],[0,2,0],[4,2,0]], [[0,0,1],[1,0,1],[2,0,1],[3,0,1],[4,0,1],[0,1,1],[4,1,1],[0,2,1],[4,2,1]], [[2,1,0],[2,2,0],[2,3,0],[1,2,0],[3,2,0]], [[2,1,1],[2,2,1],[2,3,1]]]),
            defineLevel("19. Xå‹æˆ˜æœº", [[[2,2,2],[1,2,1],[0,2,0],[3,2,3],[4,2,4]], [[2,2,2],[3,2,1],[4,2,0],[1,2,3],[0,2,4]], [[2,2,2],[2,3,2],[2,1,2],[2,2,1],[2,2,3]], [[2,2,2],[2,1,1],[2,1,3]]]),
            defineLevel("20. é‡‘å­—å¡”ä¹‹å·…", [[[0,0,0],[1,0,0],[2,0,0],[0,0,1],[2,0,1],[0,0,2],[1,0,2],[2,0,2]], [[1,0,1],[1,1,1]], [[0,1,0],[1,1,0],[2,1,0],[0,1,2],[2,1,2]], [[0,1,1],[2,1,1],[0,2,0],[2,2,2]], [[1,1,2],[1,2,2]], [[1,2,0],[1,2,1],[1,3,1]]]),
            
            // 21-30 æŠ½è±¡ä¸æ ¸å¿ƒ
            defineLevel("21. é‡å­æ ¸å¿ƒ", [[[1,1,1],[1,1,0],[1,0,1],[0,1,1],[2,1,1],[1,2,1],[1,1,2]], [[0,0,0],[1,0,0],[0,1,0],[0,0,1]], [[2,0,0],[1,0,0],[2,1,0],[2,0,1]], [[0,2,0],[1,2,0],[0,1,0],[0,2,1]], [[0,0,2],[1,0,2],[0,1,2],[0,0,1]], [[2,2,2],[1,2,2],[2,1,2],[2,2,1]]]),
            defineLevel("22. åŸå¸‚å¤©é™…çº¿", [[[0,0,0],[0,1,0],[0,2,0],[0,3,0],[0,4,0]], [[1,0,0],[1,1,0],[1,2,0]], [[2,0,0],[2,1,0],[2,2,0],[2,3,0]], [[3,0,0],[3,1,0]], [[0,0,1],[1,0,1],[2,0,1],[3,0,1]], [[1,1,1],[2,1,1]]]),
            defineLevel("23. æœºæ¢°é½¿è½®", [[[1,1,1],[0,1,1],[2,1,1],[1,0,1],[1,2,1]], [[1,1,1],[1,1,0],[1,1,2]], [[0,0,1],[0,2,1],[2,0,1],[2,2,1]], [[1,0,0],[1,0,2],[1,2,0],[1,2,2]]]),
            defineLevel("24. è«æ¯”ä¹Œæ–¯ç¯", [[[0,0,0],[1,0,0],[2,0,0],[3,0,0]], [[3,0,1],[3,0,2]], [[3,1,2],[2,1,2],[1,1,2],[0,1,2]], [[0,1,1],[0,1,0]], [[0,0,1]], [[3,1,1]]]),
            defineLevel("25. ä¸ƒå·§æ¿ç«‹æ–¹", [[[0,0,0],[1,0,0],[0,1,0],[0,0,1]], [[1,1,1],[0,1,1],[1,0,1],[1,1,0]], [[1,0,0],[1,1,0],[1,0,1]], [[0,1,0],[0,1,1],[1,1,1]], [[0,0,1],[0,1,1],[1,0,1]]]),
            defineLevel("26. åƒç´ çˆ±å¿ƒ", [[[1,0,0],[2,0,0],[0,1,0],[1,1,0],[2,1,0],[3,1,0],[0,2,0],[1,2,0],[2,2,0],[3,2,0],[1,3,0],[2,3,0]]]), // Single giant piece? Split it.
            // Split 26
            defineLevel("26. åƒç´ çˆ±å¿ƒ", [[[1,0,0],[2,0,0],[1,1,0],[2,1,0]], [[0,1,0],[0,2,0],[1,2,0],[1,3,0]], [[3,1,0],[3,2,0],[2,2,0],[2,3,0]]]),
            defineLevel("27. åŸå ¡å¤§é—¨", [[[0,0,0],[0,1,0],[0,2,0],[0,3,0],[0,4,0]], [[3,0,0],[3,1,0],[3,2,0],[3,3,0],[3,4,0]], [[0,3,0],[1,3,0],[2,3,0],[3,3,0]], [[1,4,0],[2,4,0]], [[0,0,1],[0,1,1],[3,0,1],[3,1,1]]]),
            defineLevel("28. é€»è¾‘é—¨", [[[0,0,0],[0,1,0],[0,2,0],[1,2,0],[2,2,0],[2,1,0],[2,0,0]], [[1,1,0],[1,0,0]], [[0,0,1],[0,1,1],[0,2,1]], [[2,0,1],[2,1,1],[2,2,1]], [[1,2,1]]]),
            defineLevel("29. èƒ½é‡æ°´æ™¶", [[[1,1,0],[1,1,1],[1,1,2]], [[0,1,1],[1,0,1],[2,1,1],[1,2,1]], [[0,0,1],[2,0,1],[0,2,1],[2,2,1]], [[0,1,0],[2,1,0],[1,0,0],[1,2,0]], [[0,1,2],[2,1,2],[1,0,2],[1,2,2]]]),
            defineLevel("30. ç»ˆææ–¹ç¢‘", [[[0,0,0],[1,0,0],[2,0,0],[0,1,0],[0,2,0]], [[2,0,0],[2,1,0],[2,2,0],[1,2,0]], [[1,1,1],[1,1,0]], [[0,0,1],[1,0,1],[2,0,1],[0,1,1],[0,2,1]], [[2,1,1],[2,2,1],[1,2,1]], [[0,0,2],[1,0,2],[2,0,2],[0,1,2],[0,2,2]], [[2,1,2],[2,2,2],[1,2,2]]])
        ];

        // --- åˆå§‹åŒ–ç³»ç»Ÿ ---
        function init() {
            const container = document.getElementById('canvas-container');

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0); 
            scene.fog = new THREE.Fog(0xf0f0f0, 10, 80);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // ç¯å…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(20, 30, 20); 
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 1024;
            dirLight.shadow.mapSize.height = 1024;
            dirLight.shadow.camera.left = -25;
            dirLight.shadow.camera.right = 25;
            dirLight.shadow.camera.top = 25;
            dirLight.shadow.camera.bottom = -25;
            scene.add(dirLight);

            // åœ°é¢ç½‘æ ¼
            const gridHelper = new THREE.GridHelper(60, 60, 0xdddddd, 0xeeeeee);
            gridHelper.position.set(0.5, -0.5, 0.5); 
            scene.add(gridHelper);

            // åˆå§‹åŒ–UI
            const levelSelect = document.getElementById('level-select');
            LEVELS.forEach((level, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.text = level.name;
                levelSelect.appendChild(option);
            });
            levelSelect.addEventListener('change', (e) => {
                loadLevel(parseInt(e.target.value));
                levelSelect.blur();
            });

            // è§¦æ‘¸äº‹ä»¶ç›‘å¬ (ç»‘å®šåˆ° canvas)
            const canvas = renderer.domElement;
            canvas.addEventListener('touchstart', onTouchStart, { passive: false });
            canvas.addEventListener('touchmove', onTouchMove, { passive: false });
            canvas.addEventListener('touchend', onTouchEnd, { passive: false });

            document.getElementById('reset-btn').addEventListener('click', () => loadLevel(currentLevelIndex));
            document.getElementById('next-level-btn').addEventListener('click', nextLevel);

            updateCamera();
            loadLevel(0); 
            animate();
            
            // é»˜è®¤å±•å¼€æç¤º 2ç§’åæ”¶èµ·
            setTimeout(() => {
                const help = document.getElementById('help-content');
            }, 500);
        }

        // --- å¸®åŠ©é¢æ¿åˆ‡æ¢ ---
        window.toggleHelp = function() {
            const help = document.getElementById('help-content');
            help.classList.toggle('expanded');
        }

        function loadLevel(index) {
            if (index < 0 || index >= LEVELS.length) index = 0;
            document.getElementById('win-modal').style.display = 'none';
            document.getElementById('next-level-btn').disabled = false;

            if(targetArea) scene.remove(targetArea);
            pieces.forEach(p => scene.remove(p));
            pieces = [];
            targetVoxels.clear();

            currentLevelIndex = index;
            document.getElementById('level-select').value = index;
            const levelData = LEVELS[index];
            document.getElementById('progress-fill').style.width = '0%';

            // ç›®æ ‡çº¿æ¡†
            const bounds = getBounds(levelData.target);
            const centerOffset = new THREE.Vector3(-(bounds.max.x + bounds.min.x) / 2, 0, -(bounds.max.z + bounds.min.z) / 2);

            levelData.target.forEach(pos => {
                targetVoxels.add(`${Math.round(pos[0]+centerOffset.x)},${Math.round(pos[1]+centerOffset.y)},${Math.round(pos[2]+centerOffset.z)}`);
            });

            const targetGroup = new THREE.Group();
            const geometry = new THREE.BoxGeometry(CONFIG.gridSize, CONFIG.gridSize, CONFIG.gridSize);
            const edges = new THREE.EdgesGeometry(geometry);
            const lineMat = new THREE.LineBasicMaterial({ color: 0x333333, transparent: true, opacity: 0.5 });
            const fillMat = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.05, depthWrite: false });
            
            levelData.target.forEach(v => {
                const line = new THREE.LineSegments(edges, lineMat);
                line.position.set(v[0], v[1], v[2]);
                targetGroup.add(line);
                const mesh = new THREE.Mesh(geometry, fillMat);
                mesh.position.set(v[0], v[1], v[2]);
                mesh.scale.setScalar(0.98); 
                targetGroup.add(mesh);
            });
            
            targetArea = targetGroup;
            targetArea.position.copy(centerOffset).round();
            scene.add(targetArea);

            // ç”Ÿæˆç§¯æœ¨
            levelData.pieces.forEach((pData, i) => {
                const pieceGroup = createPieceGroup(pData.shape, CONFIG.colors[pData.color % CONFIG.colors.length]);
                const angle = (i / levelData.pieces.length) * Math.PI * 2;
                const r = 10;
                pieceGroup.position.set(Math.round(Math.cos(angle) * r), 1, Math.round(Math.sin(angle) * r));
                snapToGrid(pieceGroup);
                
                // éšæœºæ—‹è½¬
                const rotY = Math.floor(Math.random() * 4);
                pieceGroup.rotation.y = rotY * (Math.PI/2);
                pieceGroup.updateMatrixWorld();
                snapToGrid(pieceGroup);

                pieceGroup.userData.originalShape = pData.shape;
                pieceGroup.userData.id = i;

                scene.add(pieceGroup);
                pieces.push(pieceGroup);
            });

            selectedObject = null;
        }

        function createPieceGroup(shape, colorHex) {
            const group = new THREE.Group();
            const material = new THREE.MeshLambertMaterial({ color: colorHex, opacity: 0.95 });
            let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity, minZ=Infinity, maxZ=-Infinity;
            shape.forEach(v => {
                minX=Math.min(minX,v[0]); maxX=Math.max(maxX,v[0]);
                minY=Math.min(minY,v[1]); maxY=Math.max(maxY,v[1]);
                minZ=Math.min(minZ,v[2]); maxZ=Math.max(maxZ,v[2]);
            });
            const center = new THREE.Vector3((minX+maxX)/2+0.5, (minY+maxY)/2+0.5, (minZ+maxZ)/2+0.5);
            shape.forEach(v => {
                 const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.96, 0.96, 0.96), material);
                 mesh.position.set(v[0], v[1], v[2]);
                 mesh.castShadow = true; mesh.receiveShadow = true;
                 group.add(mesh);
            });
            group.children.forEach(c => c.position.sub(center));
            group.userData.centerOffset = center; 
            return group;
        }

        function getBounds(voxels) {
            let min = new THREE.Vector3(Infinity, Infinity, Infinity);
            let max = new THREE.Vector3(-Infinity, -Infinity, -Infinity);
            voxels.forEach(v => {
                min.x=Math.min(min.x,v[0]); min.y=Math.min(min.y,v[1]); min.z=Math.min(min.z,v[2]);
                max.x=Math.max(max.x,v[0]); max.y=Math.max(max.y,v[1]); max.z=Math.max(max.z,v[2]);
            });
            return { min, max };
        }

        function snapToGrid(object) {
            const centerRaw = object.userData.centerOffset.clone().applyEuler(object.rotation);
            object.position.x = Math.round(object.position.x - centerRaw.x) + centerRaw.x;
            object.position.y = Math.round(object.position.y - centerRaw.y) + centerRaw.y;
            object.position.z = Math.round(object.position.z - centerRaw.z) + centerRaw.z;
        }

        // --- è§¦æ§äº‹ä»¶å¤„ç† ---

        function onTouchStart(event) {
            event.preventDefault(); // é˜²æ­¢æ»šåŠ¨
            
            const touches = event.touches;
            
            if (touches.length === 1) {
                // å•æŒ‡æ“ä½œï¼šå¯èƒ½æ˜¯æ‹–æ‹½ç‰©ä½“ï¼Œä¹Ÿå¯èƒ½æ˜¯è½¬åŠ¨è§†è§’
                const touch = touches[0];
                lastTouchX = touch.clientX;
                lastTouchY = touch.clientY;

                // å°„çº¿æ£€æµ‹
                touchPos.x = (touch.clientX / window.innerWidth) * 2 - 1;
                touchPos.y = -(touch.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(touchPos, camera);

                const intersects = raycaster.intersectObjects(pieces, true);
                
                if (intersects.length > 0) {
                    // é€‰ä¸­ç‰©ä½“
                    isDraggingPiece = true;
                    isOrbiting = false;
                    draggedObject = intersects[0].object.parent;
                    selectedObject = draggedObject; // è®¾ä¸ºå½“å‰é€‰ä¸­ï¼Œä¾›æ—‹è½¬æŒ‰é’®ä½¿ç”¨
                    highlightSelected(draggedObject);

                    // è®¡ç®—æ‹–æ‹½åç§»
                    const normal = isVerticalMode 
                        ? new THREE.Vector3(camera.position.x, 0, camera.position.z).normalize() 
                        : new THREE.Vector3(0, 1, 0);
                    dragPlane.setFromNormalAndCoplanarPoint(normal, draggedObject.position);
                    
                    if (raycaster.ray.intersectPlane(dragPlane, intersection)) {
                        offset.copy(intersection).sub(draggedObject.position);
                    }
                    setPieceOpacity(draggedObject, 0.7);

                } else {
                    // æ²¡æœ‰ç‚¹ä¸­ç‰©ä½“ -> è½¬åŠ¨è§†è§’
                    isDraggingPiece = false;
                    isOrbiting = true;
                }
            } else if (touches.length === 2) {
                // åŒæŒ‡æ“ä½œ -> ç¼©æ”¾
                isOrbiting = false;
                isDraggingPiece = false;
                const dx = touches[0].clientX - touches[1].clientX;
                const dy = touches[0].clientY - touches[1].clientY;
                lastPinchDist = Math.sqrt(dx*dx + dy*dy);
            }
        }

        function onTouchMove(event) {
            event.preventDefault();
            const touches = event.touches;

            if (touches.length === 1) {
                const touch = touches[0];
                const deltaX = touch.clientX - lastTouchX;
                const deltaY = touch.clientY - lastTouchY;

                if (isDraggingPiece && draggedObject) {
                    // æ‹–æ‹½ç‰©ä½“é€»è¾‘
                    touchPos.x = (touch.clientX / window.innerWidth) * 2 - 1;
                    touchPos.y = -(touch.clientY / window.innerHeight) * 2 + 1;
                    raycaster.setFromCamera(touchPos, camera);

                    const normal = isVerticalMode 
                        ? new THREE.Vector3(camera.position.x, 0, camera.position.z).normalize() 
                        : new THREE.Vector3(0, 1, 0);
                    dragPlane.setFromNormalAndCoplanarPoint(normal, draggedObject.position);

                    if (raycaster.ray.intersectPlane(dragPlane, intersection)) {
                        let targetPos = intersection.sub(offset);
                        if(isVerticalMode) {
                            draggedObject.position.y = Math.max(CONFIG.bounds.yMin, Math.min(CONFIG.bounds.yMax, targetPos.y));
                        } else {
                            draggedObject.position.x = Math.max(CONFIG.bounds.xMin, Math.min(CONFIG.bounds.xMax, targetPos.x));
                            draggedObject.position.z = Math.max(CONFIG.bounds.zMin, Math.min(CONFIG.bounds.zMax, targetPos.z));
                        }
                    }

                } else if (isOrbiting) {
                    // æ—‹è½¬è§†è§’é€»è¾‘
                    theta -= deltaX * 0.005;
                    phi += deltaY * 0.005;
                    phi = Math.max(0.1, Math.min(Math.PI / 2 - 0.1, phi));
                    updateCamera();
                }

                lastTouchX = touch.clientX;
                lastTouchY = touch.clientY;

            } else if (touches.length === 2) {
                // ç¼©æ”¾é€»è¾‘
                const dx = touches[0].clientX - touches[1].clientX;
                const dy = touches[0].clientY - touches[1].clientY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                const delta = lastPinchDist - dist;
                radius += delta * 0.1;
                radius = Math.max(10, Math.min(60, radius));
                updateCamera();
                
                lastPinchDist = dist;
            }
        }

        function onTouchEnd(event) {
            event.preventDefault();
            if (isDraggingPiece && draggedObject) {
                snapToGrid(draggedObject);
                setPieceOpacity(draggedObject, 0.95);
                checkWin();
            }
            isDraggingPiece = false;
            isOrbiting = false;
            draggedObject = null;
        }

        // --- æŒ‰é’®åŠŸèƒ½ ---

        function toggleMoveMode() {
            isVerticalMode = !isVerticalMode;
            const btn = document.getElementById('toggle-mode-btn');
            const hint = document.getElementById('mode-hint');
            
            if (isVerticalMode) {
                btn.innerHTML = "â†•";
                btn.classList.add('active-mode');
                hint.innerText = "å½“å‰æ¨¡å¼: å‚ç›´å‡é™";
            } else {
                btn.innerHTML = "â†”";
                btn.classList.remove('active-mode');
                hint.innerText = "å½“å‰æ¨¡å¼: æ°´å¹³ç§»åŠ¨";
            }
            
            // æ˜¾ç¤ºæç¤º 2ç§’
            hint.style.opacity = 1;
            setTimeout(() => hint.style.opacity = 0, 2000);
        }

        function rotateSelected(axis) {
            if (!selectedObject) return;
            
            if (axis === 'x') selectedObject.rotation.x += Math.PI / 2;
            if (axis === 'y') selectedObject.rotation.y += Math.PI / 2;
            if (axis === 'z') selectedObject.rotation.z += Math.PI / 2;
            
            selectedObject.updateMatrixWorld();
            snapToGrid(selectedObject);
            checkWin();
        }
        
        // --- è¾…åŠ©è§†è§‰ ---
        function highlightSelected(obj) {
            pieces.forEach(p => {
                p.children.forEach(c => c.material.emissive.setHex(0x000000));
            });
            if(obj) {
                obj.children.forEach(c => c.material.emissive.setHex(0x333333));
            }
        }

        function setPieceOpacity(group, opacity) {
            group.children.forEach(c => c.material.opacity = opacity);
        }

        function checkWin() {
            let occupiedVoxels = new Set();
            let overlap = false;
            let correctCount = 0;
            const tempVec = new THREE.Vector3();

            pieces.forEach(group => {
                group.updateMatrixWorld();
                group.children.forEach(mesh => {
                    mesh.getWorldPosition(tempVec);
                    const key = `${Math.round(tempVec.x)},${Math.round(tempVec.y)},${Math.round(tempVec.z)}`;
                    if (occupiedVoxels.has(key)) overlap = true;
                    occupiedVoxels.add(key);
                    if (targetVoxels.has(key)) correctCount++;
                });
            });

            const progress = (correctCount / targetVoxels.size) * 100;
            document.getElementById('progress-fill').style.width = `${Math.min(100, progress)}%`;

            if (!overlap && occupiedVoxels.size === targetVoxels.size && correctCount === targetVoxels.size) {
                setTimeout(() => {
                    document.getElementById('win-modal').style.display = 'block';
                    triggerConfetti();
                }, 300);
            }
        }

        function nextLevel() {
            document.getElementById('next-level-btn').disabled = true;
            if (currentLevelIndex < LEVELS.length - 1) loadLevel(currentLevelIndex + 1);
            else { alert("æ­å–œé€šå…³ï¼"); loadLevel(0); }
        }

        function updateCamera() {
            camera.position.x = radius * Math.sin(theta) * Math.cos(phi);
            camera.position.y = radius * Math.sin(phi);
            camera.position.z = radius * Math.cos(theta) * Math.cos(phi);
            camera.lookAt(0, 0, 0);
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function triggerConfetti() {
            const colors = [0xE57373, 0x64B5F6, 0x81C784, 0xFFD54F];
            for(let i=0; i<80; i++) {
                const geo = new THREE.BoxGeometry(0.3, 0.3, 0.3);
                const mat = new THREE.MeshBasicMaterial({ color: colors[Math.floor(Math.random()*colors.length)] });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(targetArea.position);
                mesh.position.x += (Math.random()-0.5)*8; mesh.position.y += Math.random()*8+4; mesh.position.z += (Math.random()-0.5)*8;
                scene.add(mesh);
                const anim = () => {
                    mesh.position.y -= 0.15; mesh.rotation.x+=0.2;
                    if(mesh.position.y>-5) requestAnimationFrame(anim); else scene.remove(mesh);
                };
                anim();
            }
        }

        init();
    </script>
</body>
</html>
